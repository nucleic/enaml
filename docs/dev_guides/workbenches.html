
<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Enaml Workbench Developer Crash Course &mdash; Enaml 0.9.1 documentation</title>
    
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootswatch-3.0.0/cosmo/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.9.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-1.9.1.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.0.0/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <link rel="top" title="Enaml 0.9.1 documentation" href="../index.html" />
    <link rel="up" title="Developer Guides" href="index.html" />
    <link rel="next" title="Architecture Reference" href="../arch_ref/index.html" />
    <link rel="prev" title="Style Sheets" href="stylesheets.html" />
  
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  <link rel="stylesheet" href="../_static/enamldoc.css" type="text/css" />
  <script type="text/javascript" src="../_static/enamldoc.js"></script>

  </head>
  <body>
  
  


  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html">Enaml</a>
        <span class="navbar-text navbar-version pull-left"><b>0.9.1</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            <li class="divider-vertical"></li>
            
            
              <li class="dropdown globaltoc-container">
  <a href="../index.html"
     class="dropdown-toggle"
     data-toggle="dropdown">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
    ><ul>
<li class="toctree-l1"><a class="reference internal" href="../get_started/index.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html">Developer Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../arch_ref/index.html">Architecture Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faqs/index.html">FAQs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api_ref/index.html">API Reference</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"><ul>
<li><a class="reference internal" href="#">Enaml Workbench Developer Crash Course</a><ul>
<li><a class="reference internal" href="#concepts">Concepts</a></li>
<li><a class="reference internal" href="#terminology">Terminology</a></li>
<li><a class="reference internal" href="#workflow">Workflow</a></li>
<li><a class="reference internal" href="#core-classes">Core Classes</a><ul>
<li><a class="reference internal" href="#workbench">Workbench</a></li>
<li><a class="reference internal" href="#pluginmanifest">PluginManifest</a></li>
<li><a class="reference internal" href="#plugin">Plugin</a></li>
<li><a class="reference internal" href="#extensionpoint">ExtensionPoint</a></li>
<li><a class="reference internal" href="#extension">Extension</a></li>
</ul>
</li>
<li><a class="reference internal" href="#core-plugin">Core Plugin</a><ul>
<li><a class="reference internal" href="#command">Command</a></li>
<li><a class="reference internal" href="#executionevent">ExecutionEvent</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ui-plugin">UI Plugin</a><ul>
<li><a class="reference internal" href="#workbenchwindow">WorkbenchWindow</a></li>
<li><a class="reference internal" href="#branding">Branding</a></li>
<li><a class="reference internal" href="#menuitem">MenuItem</a></li>
<li><a class="reference internal" href="#itemgroup">ItemGroup</a></li>
<li><a class="reference internal" href="#actionitem">ActionItem</a></li>
<li><a class="reference internal" href="#workspace">Workspace</a></li>
<li><a class="reference internal" href="#autostart">Autostart</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ui-workbench">UI Workbench</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
            
    <li><a href="../genindex.html", title="Index">Index</a></li>

            
              <li></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-3">
      <div id="enamldoc-sidebar" class="enamldoc-sidenav" role="complementary"><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../get_started/index.html">Getting Started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Developer Guides</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="stylesheets.html">Style Sheets</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">Enaml Workbench Developer Crash Course</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#concepts">Concepts</a></li>
<li class="toctree-l3"><a class="reference internal" href="#terminology">Terminology</a></li>
<li class="toctree-l3"><a class="reference internal" href="#workflow">Workflow</a></li>
<li class="toctree-l3"><a class="reference internal" href="#core-classes">Core Classes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#workbench">Workbench</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pluginmanifest">PluginManifest</a></li>
<li class="toctree-l4"><a class="reference internal" href="#plugin">Plugin</a></li>
<li class="toctree-l4"><a class="reference internal" href="#extensionpoint">ExtensionPoint</a></li>
<li class="toctree-l4"><a class="reference internal" href="#extension">Extension</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#core-plugin">Core Plugin</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#command">Command</a></li>
<li class="toctree-l4"><a class="reference internal" href="#executionevent">ExecutionEvent</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#ui-plugin">UI Plugin</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#workbenchwindow">WorkbenchWindow</a></li>
<li class="toctree-l4"><a class="reference internal" href="#branding">Branding</a></li>
<li class="toctree-l4"><a class="reference internal" href="#menuitem">MenuItem</a></li>
<li class="toctree-l4"><a class="reference internal" href="#itemgroup">ItemGroup</a></li>
<li class="toctree-l4"><a class="reference internal" href="#actionitem">ActionItem</a></li>
<li class="toctree-l4"><a class="reference internal" href="#workspace">Workspace</a></li>
<li class="toctree-l4"><a class="reference internal" href="#autostart">Autostart</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#ui-workbench">UI Workbench</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../arch_ref/index.html">Architecture Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faqs/index.html">FAQs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api_ref/index.html">API Reference</a></li>
</ul>

      </div>
    </div>
  

    <div class="col-md-9">
      
  <div class="section" id="enaml-workbench-developer-crash-course">
<span id="workbenches"></span><h1>Enaml Workbench Developer Crash Course<a class="headerlink" href="#enaml-workbench-developer-crash-course" title="Permalink to this headline">Â¶</a></h1>
<p>This document is a short introduction to the Enaml Workbench plugin framework.
It is intended for developers of plugin applications that need to get up and
running with the framework in a short amount of time. The Workbench framework
is not large, and a good developer can be comfortable with it in an afternoon.</p>
<p>This document covers the concepts, terminology, workflow, and the core plugins
and classes of the framework. The accompanying example demonstrates the various
parts of the framework with a simple plugin application which allows the user
to toggle between a handful of sample views.</p>
<div class="section" id="concepts">
<h2>Concepts<a class="headerlink" href="#concepts" title="Permalink to this headline">Â¶</a></h2>
<p>Writing large applications is hard. Writing large UI applications is harder.
Writing large UI applications which can be <em>safetly extended at runtime</em> by
other developers is a recipe for hair loss. There are several difficult issues
which  must be addressed when developing such applications, some of the most
notable are:</p>
<dl class="docutils">
<dt>Registration</dt>
<dd>How does user code get dynamically registered and unregistered at runtime?</dd>
<dt>Life Cyle</dt>
<dd>When and how should user code be loaded and run? How and when and how
should it be unloaded and stopped?</dd>
<dt>Dependencies</dt>
<dd>How does the application get started without requiring all user code to
be available at startup? How does the application avoid loading external
dependencies until they are actually required to do work?</dd>
<dt>Notifications</dt>
<dd>How can various parts of the application be notified when user code is
registered and unregistered?</dd>
<dt>User Interfaces</dt>
<dd>How can the application be flexible enough to allow user code to add
user interface elements to the window at runtime, without clobbering
or interfering with the existing user interface elements?</dd>
<dt>Flexibility</dt>
<dd>How can an application be designed in a way where it may be extended
to support future use cases which have not yet been conceived?</dd>
<dt>Ease of Use</dt>
<dd>How can all of these difficult problems be solved in such a way that
a good developer can be comfortable developing with the application
in an afternoon?</dd>
</dl>
<p>The Enaml Workbench framework attempts to solve these problems by providing
a set of low-level components which can be used to develop high-level plugin
applications. Think of it as a mini-Eclipse framework for Enaml.</p>
<p>Unlike Eclipse however, the Enaml Workbench framework strives to be compact
and efficient. Following the &#8220;less is more&#8221; mantra, it seeks to provide only
the core low-level features required for generic plugin applications. It is
intended that the core development team for a large application will build
domain specific abstractions on top of the core workbench pieces which will
then used to assemble the final application.</p>
</div>
<div class="section" id="terminology">
<h2>Terminology<a class="headerlink" href="#terminology" title="Permalink to this headline">Â¶</a></h2>
<p>Before continuuing with the crash course, the following terminology is
introduced and used throughout the rest of the document.</p>
<dl class="docutils">
<dt>Workbench</dt>
<dd>The core framework object which manages the registration of plugin
manifests and the creation of plugin objects. It acts as the central
registry and primary communication hub for the various parts of a
plugin application.</dd>
<dt>Plugin Manifest</dt>
<dd>An object which declares a plugin and its public behavior. It does
not provide an implementation of that behavior.</dd>
<dt>Plugin</dt>
<dd>An object which can be dynamically loaded and unloaded from a workbench.
It is the implementation of the behavior defined by its plugin manifest.
This term is often overload to also indicate the collection of manifest,
plugin, extension points, and extensions. That is, &#8216;plugin&#8217; can refer to
the actual plugin instance, or the entire package of related objects
written by the developer.</dd>
<dt>Extension Point</dt>
<dd>A declaration in a plugin manifest which advertises that other plugins
may contribute functionality to this plugin through extensions. It
defines the interface to which an extension must conform in order to
be useful to the plugin which declares the extension point.</dd>
<dt>Extension</dt>
<dd>A contribution to the extension point of a plugin. An extension adds
functionality and behavior to an existing application by implementing
the interface required by a given extension point.</dd>
</dl>
</div>
<div class="section" id="workflow">
<h2>Workflow<a class="headerlink" href="#workflow" title="Permalink to this headline">Â¶</a></h2>
<p>Using the workbench framework is relatively straightforward and has only
a few conceptual steps.</p>
<ol class="arabic simple" start="0">
<li>Define the classes which implement your application business logic.</li>
<li>If your application will create a plugin which contribute extensions
to an extension point, define the extension classes and ensure that
they implement the interface required by the extension point. The
extension classes should interact with the business logic classes to
expose their functionality to the rest of the application.</li>
<li>If your application will create a plugin which defines new extension
points, define a Plugin subclasses which will implement the extension
point behavior by interacting with the extensions contributed to the
extension point by other plugins.</li>
<li>Create a PluginManifest for each plugin defined by your application.
The manifest will declare the extension points provided by the plugin
as well as the extensions it contributes to other extension points. If
needed, it will supply a factory to create the custom Plugin object.</li>
<li>Create an instance of Workbench or one of its subclasses.</li>
<li>Register the plugin manifests required by your application with the
workbench. Only the plugins required for startup need to be registered.
Additional manifest can be added and removed dynamically at runtime.</li>
<li>Start the application. How this is done is application dependent.</li>
</ol>
<p>Points 0 - 3 require the most mental effort. The framework provides a few pre-
defined plugins and Workbench subclasses (described later) which make the last
few steps of the process more-or-less trivial.</p>
<p>The important takeaway here is that the application business logic should be
defined first, and then be bundled up as extensions and extension points to
expose that logic to various other parts of the application. This design
pattern forces a strong separation between logical components. And while it
requires a bit more up-front work, it results in better code reuse and a more
maintainable and extensible code base.</p>
</div>
<div class="section" id="core-classes">
<h2>Core Classes<a class="headerlink" href="#core-classes" title="Permalink to this headline">Â¶</a></h2>
<p>This section covers the core classes of the workbench framework.</p>
<div class="section" id="workbench">
<h3>Workbench<a class="headerlink" href="#workbench" title="Permalink to this headline">Â¶</a></h3>
<p>The Workbench class acts as the fundamental registry and manager object for
all the other parts of the plugin framework. As a central hub, it&#8217;s usually
possible to access any object of interest in the application by starting with
a reference to the workbench object.</p>
<p>The core <cite>Workbench</cite> class can be imported from <cite>enaml.workbench.api</cite>.</p>
<p>The core <cite>Workbench</cite> class may be used directly, though application developers
will typically create a subclass to register default plugins on startup. A
perfect example of this is the <cite>UIWorkbench</cite> subclass which registers the
&#8216;enaml.workbench.core&#8217; and &#8216;enaml.workbench.ui&#8217; plugins when started.</p>
<p>The following methods on a Workbench are of particular interest:</p>
<dl class="docutils">
<dt>register</dt>
<dd>This method is used to register a <cite>PluginManifest</cite> instance with the
workbench. This is the one-and-only way to contribute plugins to an
application, whether during initialization or later at runtime.</dd>
<dt>unregister</dt>
<dd>This method is used to unregister a plugin manifest which was previously
added to the workbench with a call to <cite>register</cite>. This is the one-and-
only way to remove plugins from the workbench application.</dd>
<dt>get_plugin</dt>
<dd>This method is used to query for, and lazily create, the plugin object
for a given manifest. The plugin object will be created the <em>first</em> time
this method is called. Future calls will return the cached plugin object.</dd>
<dt>get_extension_point</dt>
<dd>This method will return the extension point declared by a plugin. The
extension point can be queried for contributed extensions at runtime.</dd>
</dl>
</div>
<div class="section" id="pluginmanifest">
<h3>PluginManifest<a class="headerlink" href="#pluginmanifest" title="Permalink to this headline">Â¶</a></h3>
<p>The PluginManifest class is used to describe a plugin in terms of its
extension points and extensions. It also defines a globally unique
identifier for the plugin along with an optional factory function which
can be used to create the underlying plugin instance when needed.</p>
<p>The <cite>PluginManifest</cite> class can be imported from <cite>enaml.workbench.api</cite>.</p>
<p>The PluginManifest class is a declarative class and defines the following
attributes of interest:</p>
<dl class="docutils">
<dt>id</dt>
<dd>This is a globally unique identifier which identifies both the manifest
and the plugin which will be created for it. It should be a string in
dot-separated form, typically &#8216;org.pkg.module.name&#8217;. It also serves as
the enclosing namespace for the identifiers of its extension points and
extensions. The global uniqueness of this identifier is enforced.</dd>
<dt>factory</dt>
<dd>A callable which takes no arguments and returns an instance of Plugin.
For most use-cases, this factory can be ignored. The default factory
will create an instance of the default Plugin class which is suitable
for the frequent case of a plugin providing nothing but extensions to
the extension points of other plugins.</dd>
</dl>
<p>Since this class is declarative, children may be defined on it. In particular,
a plugin&#8217;s extension points and extensions are defined by declaring children
of type <cite>ExtensionPoint</cite> and <cite>Extension</cite> on the plugin manifest.</p>
</div>
<div class="section" id="plugin">
<h3>Plugin<a class="headerlink" href="#plugin" title="Permalink to this headline">Â¶</a></h3>
<p>The Plugin class is what does the actual work for implementing the behaviors
defined by extension points. It acts as a sort of manager, ensuring that the
extensions which were contributed to a given extension point are invoked
properly and in accordance with interface defined by the extension point.</p>
<p>Well-behaved plugins also react appropriately when extensions are added or
removed from one of their extension points at runtime.</p>
<p>The <cite>Plugin</cite> class can be imported from <cite>enaml.workbench.api</cite>.</p>
<p>It will be uncommon for most end-user developers to ever need to create a
custom plugin class. That job is reserved for core application developers
which actually define how the application can be extened. That said, there
are two methods on a plugin which will be of interest to developers:</p>
<dl class="docutils">
<dt>start</dt>
<dd>This method will be called by the workbench after it creates the
plugin. The default implementation does nothing and can be ignored
by subclasses which do not need life-cycle behavior.</dd>
<dt>stop</dt>
<dd>This method will be called by the workbench when the plugin is
removed. The default implementation does nothing and can be
ignored by subclasses which do not need life-cycle behavior.</dd>
</dl>
</div>
<div class="section" id="extensionpoint">
<h3>ExtensionPoint<a class="headerlink" href="#extensionpoint" title="Permalink to this headline">Â¶</a></h3>
<p>The ExtensionPoint class is used to publicly declare a point to which
extensions can be contributed to the plugin. Is is declared as the
child of a PluginManifest.</p>
<p>The <cite>ExtensionPoint</cite> class can be imported from <cite>enaml.workbench.api</cite>.</p>
<p>The ExtensionPoint class is a declarative class and defines the following
attributes of interest:</p>
<dl class="docutils">
<dt>id</dt>
<dd>The unique identifier for the extension point. It should be simple
string with no dots. The fully qualified id of the extension point
will be formed by dot-joining the id of the parent plugin manifest
with this id.</dd>
</dl>
<p>Declarative children of an extension point do not have any meaning as
far as the workbench framework is concerned.</p>
</div>
<div class="section" id="extension">
<h3>Extension<a class="headerlink" href="#extension" title="Permalink to this headline">Â¶</a></h3>
<p>The Extension class is used to pubclicly declare the contribution a plugin
provides to the extension point of another plugin. It is declared as the
child of a PluginManifest.</p>
<p>The <cite>Extension</cite> class can be imported from <cite>enaml.workbench.api</cite>.</p>
<p>The Extension class is a declarative class and defines the following
attributes of interest:</p>
<dl class="docutils">
<dt>id</dt>
<dd>The unique identifier for the extension. It should be simple string
with no dots. The fully qualified id of the extension will be formed
by dot-joining the id of the parent plugin manifest with this id.</dd>
<dt>point</dt>
<dd>The fully qualified id of the extension point to which the extension
is contributing.</dd>
<dt>rank</dt>
<dd>An optional integer to rank the extension among other extensions
contributed to the same extension point. The semantics of how the
rank value is used is specified by a given extension point.</dd>
<dt>factory</dt>
<dd>An optional callable which is used to create the implementation
object for an extension. The semantics of the call signature and
return value are specified by a given extension point.</dd>
</dl>
<p>Declarative children of an Extension are allowed, and their semantic meaning
are defined by a given extension point. For example, the extension point
&#8216;enaml.workbench.core.commands&#8217; allows extension commands to be defined as
declarative children of the extension.</p>
</div>
</div>
<div class="section" id="core-plugin">
<h2>Core Plugin<a class="headerlink" href="#core-plugin" title="Permalink to this headline">Â¶</a></h2>
<p>The section covers the workbench core plugin.</p>
<p>The core plugin is a pre-defined plugin supplied by the workbench framework.
It provides non-ui related functionality that is useful across a wide variety
of applications. It must be explicitly registered with a workbench in order
to be used.</p>
<p>The <cite>CoreManifest</cite> class can be imported from <cite>enaml.workbench.core.api</cite>. It
is a declarative enamldef and so must be imported from within an Enaml imports
context.</p>
<p>The id for the core plugin is &#8216;enaml.workbench.core&#8217; and it declares the
following extension points:</p>
<dl class="docutils">
<dt>&#8216;commands&#8217;</dt>
<dd>Extensions to this point may contribute <cite>Command</cite> objects which can
be invoked via the <cite>invoke_command</cite> method of the CorePlugin instance.
Commands can be provided by declaring them as children of the Extension
and/or by declaring a factory function which takes the workbench as an
argument and returns a list of Command instances.</dd>
</dl>
<div class="section" id="command">
<h3>Command<a class="headerlink" href="#command" title="Permalink to this headline">Â¶</a></h3>
<p>A Command object is used to declare that a plugin can take some action when
invoked by a user. It is declared as the child of an Extension which
contributes to the &#8216;enaml.workbench.core.commands&#8217; extension point.</p>
<p>The <cite>Command</cite> class can be imported from <cite>enaml.workbench.core.api</cite>.</p>
<p>The Command class is a declarative class and defines the following
attributes of interest:</p>
<dl class="docutils">
<dt>id</dt>
<dd>The globally unique identifier for the command. This should be a
dot-separated string. The global uniqueness is enforced.</dd>
<dt>handler</dt>
<dd>A callable object which implements the command behavior. It must
accept a single argument which is an instance of <cite>ExecutionEvent</cite>.</dd>
</dl>
</div>
<div class="section" id="executionevent">
<h3>ExecutionEvent<a class="headerlink" href="#executionevent" title="Permalink to this headline">Â¶</a></h3>
<p>An ExecutionEvent is an object which is passed to a Command handler when
it is invoked by the framework. User code will never directly create an
ExecutionEvent.</p>
<p>An ExecutionEvent has the following attributes of interest:</p>
<dl class="docutils">
<dt>command</dt>
<dd>The Command object which is being invoked.</dd>
<dt>workbench</dt>
<dd>A reference to the workbench which owns the command.</dd>
<dt>parameters</dt>
<dd>A dictionary of user-supplied parameters to the command.</dd>
<dt>trigger</dt>
<dd>The user object which triggered the command.</dd>
</dl>
</div>
</div>
<div class="section" id="ui-plugin">
<h2>UI Plugin<a class="headerlink" href="#ui-plugin" title="Permalink to this headline">Â¶</a></h2>
<p>This section covers the workbench ui plugin.</p>
<p>The ui plugin is a pre-defined plugin supplied by the workbench framework.
It provides ui-related functionality which is common to a large swath of
UI applications. It must be explicity registered with a workbench in order
to be used.</p>
<p>The <cite>UIManifest</cite> class can be imported from <cite>enaml.workbench.ui.api</cite>. It is
a declarative enamldef and so must be imported from within an Enaml imports
context.</p>
<p>The id of the ui plugin is &#8216;enaml.workbench.ui&#8217; and it declares the following
extension points:</p>
<dl class="docutils">
<dt>&#8216;application_factory&#8217;</dt>
<dd>An Extension to this point can be used to provide a custom
application object for the workbench. The extension factory should
accept no arguments and return an Application instance. The highest
ranking extension will be chosen to create the application.</dd>
<dt>&#8216;window_factory&#8217;</dt>
<dd>An Extension to this point can be used to provide a custom main
window for the workbench. The extension factory should accept the
workbench as an argument and return a WorkbenchWindow instance. The
highest ranking extension will be chosen to create the window.</dd>
<dt>&#8216;branding&#8217;</dt>
<dd>An Extension to this point can be used to provide a custom window
title and icon to the primary workbench window. A Branding object can
be declared as the child of the extension, or created by the extension
factory function which accepts the workbench as an argument. The
highest ranking extension will be chosen to provide the branding.</dd>
<dt>&#8216;actions&#8217;</dt>
<dd>Extensions to this point can be used to provide menu items and
action items to be added to the primary workbench window menu bar. The
extension can declare child MenuItem and ActionItem instances as well
as provide a factory function which returns a list of the same.</dd>
<dt>&#8216;workspaces&#8217;</dt>
<dd>Extensions to this point can be used to provide workspaces which
can be readily swapped to provide the main content for the workbench
window. The extension factory function should accep the workbench as
an argument and return an instance of Workspace.</dd>
<dt>&#8216;autostart&#8217;</dt>
<dd>Extensions to this point can be used to provide the id of a plugin
which should be started preemptively on application startup. The
extension should declare children of type Autostart. The plugins will
be started in order of extension rank. Warning - abusing this facility
can cause drastic slowdowns in application startup time. Only use it
if you are <em>absolutely</em> sure your plugin must be loaded on startup.</dd>
</dl>
<p>The plugin declares the following extensions:</p>
<dl class="docutils">
<dt>&#8216;default_application_factory&#8217;</dt>
<dd>This contributes to the &#8216;enaml.workbench.ui.application_factory&#8217;
extension point and provides a default instance of a QtApplication.</dd>
<dt>&#8216;default_window_factory&#8217;</dt>
<dd>This contributes to the &#8216;enaml.workbench.ui.window_factory&#8217; extension
point and provides a default instance of a WorkbenchWindow.</dd>
<dt>&#8216;default_commands&#8217;</dt>
<dd>This contributes to the &#8216;enaml.workbench.core.commands&#8217; extension point
and provides the default command for the plugin (described later).</dd>
</dl>
<p>The plugin provides the following commands:</p>
<dl class="docutils">
<dt>&#8216;enaml.workbench.ui.close_window&#8217;</dt>
<dd>This command will close the primary application window. It takes
no parameters.</dd>
<dt>&#8216;enaml.workbench.ui.close_workspace&#8217;</dt>
<dd>This command will close the currently active workspace. It takes
no parameters.</dd>
<dt>&#8216;enaml.workbench.ui.select_workspace&#8217;</dt>
<dd>This command will select and activate a new workspace. It takes
a single &#8216;workspace&#8217; parameter which is the fully qualified id of
the extension point which contributes the workspace of interest.</dd>
</dl>
<div class="section" id="workbenchwindow">
<h3>WorkbenchWindow<a class="headerlink" href="#workbenchwindow" title="Permalink to this headline">Â¶</a></h3>
<p>The WorkbenchWindow is an enamldef subclass of the Enaml MainWindow widget.
It is used by the ui plugin to bind to the internal ui window model which
drives the runtime dynamism of the window.</p>
<p>The will be cases where a developer wishes to create a custom workbench
window for one reason or another. This can be done subclassing the plain
WorkbenchWindow and writing a plugin which contributes a factory to the
&#8216;enaml.workbench.ui.window_factory&#8217; class.</p>
<p>The WorkbenchWindow class can be imported from <cite>enaml.workbench.ui.api</cite>.</p>
</div>
<div class="section" id="branding">
<h3>Branding<a class="headerlink" href="#branding" title="Permalink to this headline">Â¶</a></h3>
<p>The Branding class is a declarative class which can be used to apply a
custom window title and window icon to the primary application window. This
is a declarative class which can be defined as the child of an extension, or
returned from the factory of an extension which contributes to the
&#8216;enaml.workbench.ui.branding&#8217; extension point.</p>
<p>The Branding class can be imported from <cite>enaml.workbench.ui.api</cite>.</p>
<p>It has the following attributes of interest:</p>
<dl class="docutils">
<dt>title</dt>
<dd>The string to use as the primary title of the main window.</dd>
<dt>icon</dt>
<dd>The icon to use for the icon of the main window and taskbar.</dd>
</dl>
</div>
<div class="section" id="menuitem">
<h3>MenuItem<a class="headerlink" href="#menuitem" title="Permalink to this headline">Â¶</a></h3>
<p>The MenuItem class is a declarative class which can be used to declare a
menu in the primary window menu bar.</p>
<p>The MenuItem class can be imported from <cite>enaml.workbench.ui.api</cite>.</p>
<p>It has the following attributes of interest:</p>
<dl class="docutils">
<dt>path</dt>
<dd>A &#8220;/&#8221; separated path to the location of this item in the menu bar.
This path must be unique for the menu bar, and the parent path must
exist in the menu bar. The last token in the path is the id of this
menu item with respect to its siblings. For example, if the path for
the item is &#8216;/foo/bar/baz&#8217;, then &#8216;/foo/bar&#8217; is the path for the parent
menu, and &#8216;baz&#8217; is the id of the menu with respect to its siblings.
<em>The parent menu need not be defined by the same extension which
defines the menu. That is, one plugin can contribute a sub-menu to
a menu defined by another plugin.</em></dd>
<dt>group</dt>
<dd>The name of the item group defined by the parent menu to which this
menu item should be added. For a top-level menu item, the empty group
is automatically implied.</dd>
<dt>before</dt>
<dd>The id of the sibling item before which this menu item should appear.
The sibling must exist in the same group as this menu item.</dd>
<dt>after</dt>
<dd>The id of the sibling item after which this menu item should appear.
This sibling must exist in the same group as this menu item.</dd>
<dt>label</dt>
<dd>The text to diplay as the label for the menu.</dd>
<dt>visible</dt>
<dd>Whether or not the menu is visible.</dd>
<dt>enabled</dt>
<dd>Whether or not the menu is enabled.</dd>
</dl>
<p>A MenuItem can define conceptual groups in which other plugins may contribute
other menu items and action items. A group is defined by declaring a child
ItemGroup object on the menu item. The group will appear on screen in the
order in which they were declared. There is an implicit group with an empty
identifier into which all unclassified items are added. The implicit group
will always appear visually last on the screen.</p>
</div>
<div class="section" id="itemgroup">
<h3>ItemGroup<a class="headerlink" href="#itemgroup" title="Permalink to this headline">Â¶</a></h3>
<p>The ItemGroup class is a declarative class used to form a logical and
visual group of items in a menu. It is declared as a child of a MenuItem
and provides a concrete advertisement by the author of a MenuItem that it
expects other MenuItem and ActionItem instances to be added to that point
in the Menu.</p>
<p>The ItemGroup class can be imported from <cite>enaml.workbench.ui.api</cite>.</p>
<p>It has the following attributes of interest:</p>
<dl class="docutils">
<dt>id</dt>
<dd>The identifier of the group within the menu. It must be unique among
all other group siblings defined for the menu item.</dd>
<dt>visible</dt>
<dd>Whether or not the items in the group are visible.</dd>
<dt>enabled</dt>
<dd>Whether or not the items in the group are enabled.</dd>
<dt>exclusive</dt>
<dd>Whether or not neighboring checkable action items in the group
should behave as exclusive checkable items.</dd>
</dl>
</div>
<div class="section" id="actionitem">
<h3>ActionItem<a class="headerlink" href="#actionitem" title="Permalink to this headline">Â¶</a></h3>
<p>The ActionItem class is used to declare a triggerable item in a menu. It
is declared as a child of a plugin Extension object.</p>
<p>The ActionItem class can be imported from <cite>enaml.workbench.ui.api</cite>.</p>
<p>It has the following attributes of interest:</p>
<dl class="docutils">
<dt>path</dt>
<dd>A &#8220;/&#8221; separated path to the location of this item in the menu bar.
This path must be unique for the menu bar, and the parent path must
exist in the menu bar. The last token in the path is the id of this
action item with respect to its siblings. For example, if the path for
the item is &#8216;/foo/bar/baz&#8217;, then &#8216;/foo/bar&#8217; is the path for the parent
menu, and &#8216;baz&#8217; is the id of the action with respect to its siblings.
<em>The parent menu need not be defined by the same extension which
defines the action. That is, one plugin can contribute an action to a
menu defined by another plugin.</em></dd>
<dt>group</dt>
<dd>The name of the item group defined by the parent menu to which this
action item should be added.</dd>
<dt>before</dt>
<dd>The id of the sibling item before which this action item should appear.
The sibling must exist in the same group as this action item.</dd>
<dt>after</dt>
<dd>The id of the sibling item after which this action item should appear.
This sibling must exist in the same group as this action item.</dd>
<dt>command</dt>
<dd>The identifier of the Command object which should be invoked when
this action item is triggered by the user.</dd>
<dt>parameters</dt>
<dd>The dictionary of parameters which should be passed to the command
when it is invoked.</dd>
<dt>label</dt>
<dd>The text to diplay as the label for the action.</dd>
<dt>shortcut</dt>
<dd>The keyboard shortcut which should be bound to trigger action item.</dd>
<dt>visible</dt>
<dd>Whether or not the action is visible.</dd>
<dt>enabled</dt>
<dd>Whether or not the action is enabled.</dd>
<dt>checkable</dt>
<dd>Whether or not the action is checkable.</dd>
<dt>checked</dt>
<dd>Whether or not the action is checked.</dd>
<dt>icon</dt>
<dd>The icon to display next to the action.</dd>
<dt>tool_tip</dt>
<dd>The tool tip text to display when the user hovers over the action.</dd>
<dt>status_tip</dt>
<dd>The text to display in the status bar when the user hovers over the
action.</dd>
</dl>
</div>
<div class="section" id="workspace">
<h3>Workspace<a class="headerlink" href="#workspace" title="Permalink to this headline">Â¶</a></h3>
<p>The Workspace class is a declarative class which is used to supply the
central window content for a ui workbench application. It contains the
attributes and method which are necessary for the ui plugin to be able
to dynamically switch workspaces at runtime. The application developer
will typically create a custom workspace class for each one of the views
that will be shown in the workbench.</p>
<p>The Workspace class is declarative to allow the developer to fully
leverage the Enaml language in the course of defining their workspace.
It will typically be declared as the child of any object.</p>
<p>The Workspace class can be imported from <cite>enaml.workbench.ui.api</cite>.</p>
<p>It has the following attributes of interest:</p>
<dl class="docutils">
<dt>window_title</dt>
<dd>This is text which will be added to the window title <em>in addition</em>
to the title text which is supplied by a branding extension.</dd>
<dt>content</dt>
<dd>This is an Enaml Container widget which will be used as the primary
window content. It should be created during the workspace &#8216;start&#8217;
method and will be destroyed by the framework automatically when
the workspace is stopped.</dd>
</dl>
<p>It has the following methods of interest:</p>
<dl class="docutils">
<dt>start</dt>
<dd>This method is called when the UI plugin starts the workspace. This
can be used to load content or any other resource which should exist
for the life of the workspace.</dd>
<dt>stop</dt>
<dd>This method is called when the UI plugin closes the workspace. This
should be used to release any resources acquired during the lifetime
of the workspace. The content Container will be destroyed automatically
after this method returns.</dd>
</dl>
</div>
<div class="section" id="autostart">
<h3>Autostart<a class="headerlink" href="#autostart" title="Permalink to this headline">Â¶</a></h3>
<p>The Autostart class is a declarative class which is used to supply the
plugin id for a plugin which should be automatically started on application
startup.</p>
<p>The Autostart class can be imported from <cite>enaml.workbench.ui.api</cite>.</p>
<p>It has the following attributes of interest.</p>
<dl class="docutils">
<dt>plugin_id</dt>
<dd>This is the id of the plugin to start on application startup. The
manifest for the plugin must be registered before the ui plugin is
started.</dd>
</dl>
</div>
</div>
<div class="section" id="ui-workbench">
<h2>UI Workbench<a class="headerlink" href="#ui-workbench" title="Permalink to this headline">Â¶</a></h2>
<p>The UIWorkbench class is a simple sublass of Workbench for creating ui
applications. This class will automatically register the pre-defined
&#8216;core&#8217; and &#8216;ui&#8217; workbench plugins when it is started.</p>
<p>The UIWorkbench class can be imported from <cite>enaml.workbench.ui.api</cite>.</p>
<p>It has the following methods of interest:</p>
<dl class="docutils">
<dt>run</dt>
<dd>This method will load the core and ui plugins and start the
main application event loop. This is a blocking call which
will return when the application event loop exits.</dd>
</dl>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2013, Nucleic Development Team.<br/>
      Last updated on Feb 18, 2014.<br/>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.<br/>
    </p>
  </div>
</footer>
  </body>
</html>