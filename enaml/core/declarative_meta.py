#------------------------------------------------------------------------------
# Copyright (c) 2013-2022, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file LICENSE, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Atom, AtomMeta, ChangeType, DefaultValue, Member, Typed
from traceback import StackSummary, FrameSummary, format_exc
from typing import Optional, TYPE_CHECKING

from .compiler_nodes import CompilerNode, TemplateInstanceNode

if TYPE_CHECKING:
    from .declarative import Declarative

# The declarative engine only updates for these types of changes
D_CHANGE_TYPES = (
    ChangeType.UPDATE | ChangeType.PROPERTY | ChangeType.EVENT | ChangeType.DELETE
)


class DeclarativeDefaultHandler(Atom):
    """ A callable object which handles Declarative default values.

    This handler attempts to read the default value from the declarative
    engine, falling back on the default delegate if the engine does not
    have an implemented reader. Instances of this handler are created
    and installed by the DeclarativeMeta class.

    """
    delegate = Typed(Member, ())

    def __call__(self, owner, name):
        """ Invoke the declarative default handler.

        Parameters
        ----------
        owner : Declarative
            The declarative owner for which the default value should
            be computed.

        name : str
            The name of the attribute which should be read from the
            declarative engine.

        Returns
        -------
        result : object
            The default value for the object.

        """
        engine = owner._d_engine
        if engine is not None:
            value = engine.read(owner, name)
            if value is not NotImplemented:
                return value
        return self.delegate.do_default_value(owner)


def declarative_change_handler(change):
    """ A static observer which writes to a declarative engine.

    This handler will write the change to the declarative engine
    so that the engine can notify any bound expressions. This handler
    is attached by the DeclarativeMeta class.

    Parameters
    ----------
    change : dict
        The change dictionary generated by the notification.

    """
    # TODO think about whether this is the right place to filter on change_t
    # NOTE: Filtering on change['type'] is done by atom
    owner = change['object']
    engine = owner._d_engine
    if engine is not None:
        engine.write(owner, change['name'], change)


def declarative_frame_summary(compiler_node: CompilerNode, name: str) -> FrameSummary:
    """ Create the FrameSummary for a given declarative node.

    Parameters
    ----------
    node : DeclarativeNode
        The declrative node to create a frame summary for.

    Returns
    -------
    summary : FrameSummary
        The frame summary.

    """
    source = compiler_node.source_location
    if source is not None:
        filename, lineno = source
    else:
        filename = ""
        lineno = -1
    return FrameSummary(filename, lineno, name, lookup_line=False)


def find_pattern_node(node: "Declarative") -> Optional["Declarative"]:
    """ Find the pattern node which intercepted the given node, if any.

    Parameters
    ----------
    node : Declarative
        The declarative to lookup the pattern node for.

    Returns
    -------
    pattern_node : Optional[Declarative]
        The pattern node which inserted the provided node.

    """
    parent = node.parent
    if parent is not None:
        compiler_node = node._d_node
        for child in parent.children:
            if compiler_node in child._d_node.children:
                return child
    return None


def find_template_node(node: "Declarative") -> tuple:
    """ Find the template node which inserted the given node, if any.

    Parameters
    ----------
    node : Declarative
        The declarative to lookup the template for.

    Returns
    -------
    result : Optional[tuple[TemplateInstanceNode, TemplateNode]]
        The template instance node.

    """
    parent = node.parent
    if parent is not None:
        compiler_node = node._d_node
        for child_node in parent._d_node.children:
            if isinstance(child_node, TemplateInstanceNode):
                template_node = child_node.template
                if compiler_node in template_node.children:
                    return (child_node, template_node)
    return None


def declarative_stack_summary(
    node: "Declarative",
    expression: Optional[FrameSummary] = None,
) -> StackSummary:
    """ Create a stack summary for the given Declarative node.

    Parameters
    ----------
    node : Declarative
        The node to create a summary for.
    expression : Optional[FrameSummary]
        The frame summary for the expression in which was executing, if any.

    Returns
    -------
    summary : StackSummary
        The stack summary.

    """
    declarative_stack = []
    if expression is not None:
        declarative_stack.append(expression)

    while node is not None:
        parent = node.parent
        compiler_node = node._d_node
        name = node.__class__.__name__
        frame_summary = declarative_frame_summary(compiler_node, name)
        declarative_stack.append(frame_summary)

        if parent is not None and compiler_node not in parent._d_node.children:
            # When the compiler node is not in the parent compiler nodes
            # children, the child was either inserted by a pattern node which
            # intercepted children or inserted by a template.
            pattern_node = find_pattern_node(node)
            if pattern_node is not None:
                node = pattern_node
                continue

            # Attempt to find the template which inserted the child
            template_nodes = find_template_node(node)
            if template_nodes is not None:
                instance_node, template_node = template_nodes
                template_frame = declarative_frame_summary(
                    template_node, template_node.name
                )
                declarative_stack.append(template_frame)
                instance_frame = declarative_frame_summary(
                    instance_node, template_node.name
                )
                declarative_stack.append(instance_frame)

        # Up to next level
        node = parent

    declarative_stack.reverse()
    return StackSummary.from_list(declarative_stack)


class DeclarativeError(Exception):
    def __init__(
        self,
        node: "Declarative",
        exc: Exception,
        expression: Optional[FrameSummary] = None
    ):
        """ An error that occurred within a declarative block. Used to provide
        more details on the declarative stack.

        Parameters
        ----------
        node : Declarative
            The node where the exception occurred.
        exc : Exception
            The exception that ocurred.
        expression : Optional[FrameSummary]
            The frame summary for the expression in which was executing.


        """
        summary = self.summary = declarative_stack_summary(node, expression)
        stack = "".join(summary.format())
        self.error = exc
        exc_type_name = exc.__class__.__name__
        message = "\n{}{}: {}".format(stack, exc_type_name, exc)
        super().__init__(message)


def patch_d_member(member):
    """ Patch the d_ member for declarative handling.

    This function will add the default value and change handlers to
    pull data from the declarative engine.

    Parameters
    ----------
    member : Member
        A member declared as a d_ member.

    """
    metadata = member.metadata
    if metadata['d_writable']:
        handler = DeclarativeDefaultHandler()
        handler.delegate = member.clone()
        new_mode = DefaultValue.CallObject_ObjectName
        member.set_default_value_mode(new_mode, handler)
    if metadata['d_readable']:
        member.add_static_observer(declarative_change_handler, D_CHANGE_TYPES)


class DeclarativeMeta(AtomMeta):
    """ The metaclass for Declarative classes.

    This metaclass patches up the default value handlers and default
    static observers based on the 'd_' members defined on the class.
    The patching must be done after the parent metaclass runs, since
    the bindings for the default engine must occur after the standard
    default handler hookups.

    """
    #: A flag which can be set on a declarative class to indicate to
    #: the compiler that instances of the class will build out their
    #: children. If this flag is set, the class must provide a method
    #: named 'child_node_intercept' which accepts the list of nodes
    #: and the local scope for their instantiation and returns None.
    __intercepts_child_nodes__ = False

    def __new__(meta, name, bases, dct):
        """ Create a new Declarative subclass.

        """
        # Create the subclass then pass over it's update dict and
        # patch up the default value and static change handlers for
        # the d_ members. This must done *after* the main metaclass
        # runs, or the declarative default values can get clobbered.
        cls = AtomMeta.__new__(meta, name, bases, dct)
        for key, value in cls.__dict__.items():
            if isinstance(value, Member):
                metadata = value.metadata
                if metadata is not None and metadata.get('d_member'):
                    patch_d_member(value)
        return cls
